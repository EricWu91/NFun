


|****************************************
| TEST Int16 bitinverse  
| TAGS Bitwise                         
|************************  
  a:int16
  i:int16 = ~~a 
|---------------------
| set a:1
| check i:1
| set a:2
| check i:2
| set a:3
| check i:3
| set a:7
| check i:7
| set a:8
| check i:8
| set a:100
| check i:100
| set a:200
| check i:200
| set a:300
| check i:300




|****************************************
| TEST UInt16 bitinverse  
| TAGS Bitwise                         
|************************  
  a:uint16
  i:uint16 = ~~a 
|---------------------
| set a:1
| check i:1
| set a:2
| check i:2
| set a:7
| check i:7
| set a:8
| check i:8
| set a:100
| check i:100
| set a:200
| check i:200
| set a:300
| check i:300


|****************************************
| TEST sign convert chain arithmetic   
| TAGS convert                          
|************************  
  x:int16

  i16:int16 = (2*x-1)*2
  i32:int32 = (2*x-i16)+1
  i64:int64 = (2*i16-i32)-1
  r:real    = (2*i32-i64)*1
|---------------------
| set x:2
| check  i16:6, i32:-1, i64:12, r:10
| set x:0
| check  i16:-2, i32:3, i64:-8, r:14
| set x:-2
| check  i16:-10, i32:7, i64:-28, r:14



|****************************************
| TEST integers multiply user function  
| TAGS integers convert function                          
|************************  
| out i16:int16, i32:int32, i64:int64, u8:uint8, u16:uint16, u32: uint32, u64:uint64 
|------------------------
  i16Inc(i:int16) :int16 = i*2
  i32Inc(i:int32) :int32 = i*2
  i64Inc(i:int64) :int64 = i*2
  u8Inc (i:uint8) :uint8 = i*2
  u16Inc(i:uint16):uint16 = i*2
  u32Inc(i:uint32):uint32 = i*2
  u64Inc(i:uint64):uint64 = i*2
    
  x:uint8

  i16 = i16Inc(x)
  i32 = i32Inc(x)
  i64 = i64Inc(x)

  u8  = u8Inc (x)
  u16 = u16Inc(x)
  u32 = u32Inc(x)
  u64 = u64Inc(x)
  
|---------------------
| set x:2
| check i16:4, i32:4, i64:4, u8:4, u16:4, u32:4, u64:4
| set x:42
| check i16:84, i32:84, i64:84, u8:84, u16:84, u32:84, u64:84
| set x:0
| check i16:0, i32:0, i64:0, u8:0, u16:0, u32:0, u64:0





|****************************************
| TEST unsigned integers decrement user function  
| TAGS integers convert function                          
|************************  
| out ui16:uint16, ui32:uint32, ui64:uint64
|------------------------
  ui16Inc(i:uint16) :uint16 = i-1
  ui32Inc(i:uint32) :uint32 = i-1
  ui64Inc(i:int64)  :uint64 = i-1
    
  x:uint8

  ui16 = ui16Inc(x)
  ui32 = ui32Inc(x)
  ui64 = ui64Inc(x)

|---------------------
| set x:2
| check ui16:1, ui32:1, ui64:1
| set x:1
| check ui16:0, ui32:0, ui64:0



|****************************************
| TEST unsigned chain convert decrement user function  
| TAGS integers convert function                          
|************************  
| out ui16:uint16, ui32:uint32, ui64:uint64
|------------------------
  ui16Inc(i:uint16) :uint16 = i-1
  ui32Inc(i:uint32) :uint32 = i-1
  ui64Inc(i:int64)  :uint64 = i-1
    
  x:uint8

  ui16 = ui16Inc(x)
  ui32 = ui32Inc(ui32)
  ui64 = ui64Inc(ui64)
|---------------------
| set x:5
| check ui16:4, ui32:3, ui64:2
| set x:3
| check ui16:2, ui32:1, ui64:0




|****************************************
| TEST int join
| TAGS text array join
|************************
  
  origin:int[]
  origin.join(', ') 
  
|------------------
| set origin:[1,2,3,4,5]
| check out:'1, 2, 3, 4, 5'
| set origin:[3,2]
| check out:'3, 2'


|****************************************
| TEST text join
| TAGS text array join
|************************
  origin:text
  origin.join(', ') 
|------------------
| set origin:['','a','b']
| check out:', a, b'


|****************************************
| TEST trim
| TAGS text array trim
|************************
  origin.trim()
|------------------
| set origin: ' hi with start and end  '
| check out:'hi with start and end'


|****************************************
| TEST trim start
| TAGS text array trimStart
|************************
  origin.trimStart()
|------------------
| set origin: ' hi with start and end  '
| check out:'hi with start and end  '

|****************************************
| TEST trim end
| TAGS text array trimEnd
|************************
  origin.trimEnd()
|------------------
| set origin: ' hi with start and end  '
| check out:' hi with start and end'


|****************************************
| TEST text join split
| TAGS text join split
|************************
  origin:text
  origin.split(' ').join('-') 
|------------------
| set origin: 'hello my lovely world'
| check out:'hello-my-lovely-world'
| set origin:''
| check out:''
| set origin:' '
| check out:''
| set origin: ' hello   my lovely  world'
| check out:'hello-my-lovely-world'


|****************************************
| TEST int join split
| TAGS int join split
|************************
  origin.split(42).join(2) 
|------------------
| set origin: [1,42,42,2,3,42]
| check out:[1,2,2,3]



|****************************************
| TEST integers decrement user function  
| TAGS integers convert function                          
|************************  
| out i16:int16, i32:int32, i64:int64, u8:uint8, u16:uint16, u32: uint32, u64:uint64 
|------------------------
  i16Inc(i:int16) :int16 = i-1
  i32Inc(i:int32) :int32 = i-1
  i64Inc(i:int64) :int64 = i-1
  u8Inc (i:uint8) :uint8 = i-1
  u16Inc(i:uint16):uint16 = i-1
  u32Inc(i:uint32):uint32 = i-1
  u64Inc(i:uint64):uint64 = i-1
    
  x:uint8

  i16 = i16Inc(x)
  i32 = i32Inc(x)
  i64 = i64Inc(x)

  u8  = u8Inc (x)
  u16 = u16Inc(x)
  u32 = u32Inc(x)
  u64 = u64Inc(x)  
|---------------------
| set x:2
| check i16:1, i32:1, i64:1, u8:1, u16:1, u32:1, u64:1
| set x:42
| check i16:41, i32:41, i64:41, u8:41, u16:41, u32:41, u64:41



|****************************************
| TEST signed integers decrement user function  
| TAGS integers convert function                          
|************************  
| out i16:int16, i32:int32, i64:int64
|------------------------
  i16Inc(i:int16) :int16 = i-1
  i32Inc(i:int32) :int32 = i-1
  i64Inc(i:int64) :int64 = i-1
    
  x:int16

  i16 = i16Inc(x)
  i32 = i32Inc(x)
  i64 = i64Inc(x)

|---------------------
| set x:0
| check i16:-1, i32:-1, i64:-1
| set x:-1
| check i16:-2, i32:-2, i64:-2



|****************************************
| TEST text join
| TAGS text array join
|************************
  
  origin:int[]
  origin.join(', ') 
  
|------------------
| set origin:[1,2,3,4,5]
| check out:'1, 2, 3, 4, 5'
| set origin:[3,2]
| check out:'3, 2'



|****************************************
| TEST text join split
| TAGS text join split
|************************
  origin:text
  origin.split(' ').join('-') 
|------------------
| set origin: 'hello my lovely world'
| check out:'hello-my-lovely-world'
| set origin:''
| check out:''
| set origin:' '
| check out:''




|****************************************
| TEST integers increment user function  
| TAGS integers convert function                          
|*****************************  
| out i16:int16, i32:int32, i64:int64, u8:uint8, u16:uint16, u32:uint32, u64:uint64 
|------------------------
  i16Inc(i:int16) :int16 = i+1
  i32Inc(i:int32) :int32 = i+1
  i64Inc(i:int64) :int64 = i+1
  u8Inc (i:uint8) :uint8 = i+1
  u16Inc(i:uint16):uint16 = i+1
  u32Inc(i:uint32):uint32 = i+1
  u64Inc(i:uint64):uint64 = i+1
    
  x:uint8

  i16 = i16Inc(x)
  i32 = i32Inc(x)
  i64 = i64Inc(x)

  u8  = u8Inc (x)
  u16 = u16Inc(x)
  u32 = u32Inc(x)
  u64 = u64Inc(x)
  
|---------------------
| set x:2
| check i16:3, i32:3, i64:3, u8:3, u16:3, u32:3, u64:3
| set x:42
| check i16:43, i32:43, i64:43, u8:43, u16:43, u32:43, u64:43
| set x:0
| check i16:1, i32:1, i64:1, u8:1, u16:1, u32:1, u64:1



|****************************************
| TEST odds   
| TAGS built-in-function
|************************  
| in x:int[]
| out  ysum:int, ymulti: int, ymin: int, ymax:int 
|------------------------
  ysum = x.filter(i->i%2==0).sum()
  ymulti = x.filter(i->i%2).reduce((s,i)-> s*i)
  ymin = x.filter(i->i%2).reduce(min)
  ymax = x.filter(i->i%2).reduce(max)
|---------------------
| set  x:[0,1,2,3,4,5,6,7,8,9]
| check ysum:20, ymulti:384, ymin:0, ymax:8



|****************************************
| TEST linq#1   
| TAGS built-in-function map filter count 
|************************  
| in   x:text[]
| out  aaa:int[], tot:int[] 
|------------------------
 #x is array of texts
   achar = 'a'[0]
 
 # aaa is count of 'a' chars in texts, witch contains N or more 
 # 'a' chars 
   aaa = x
   		.map(s->s.count(j->j==achar))
   		.filter(s->s >= n)
 
 # tot is lengths of texts witch contain N or more  
 # 'a' chars 
   tot = x
   		.filter(
   				s-> s.count(j->j==achar) >=n
   			)    
   		.map(count)

|---------------------
| set x:['vasa','kata'], n:3
| check aaa: [], tot:[]
| set x:['vasaa','kataaa', 'jony', 'aa',  'mashaaa', 'aaa_aaa_aaa'], n:3
| check aaa: [3,4,4,9], tot:[5,6,7,11]
| set x:['vasa','kata'], n:2
| check aaa: [2,2], tot:[4,4]



|****************************************
| TEST apply array constant  
| TAGS apply array constant                         
|************************  
	i16:int16[] = [1,2,3]     
	i32:int32[] = [1,2,3]     
	i64:int64[] = [1,2,3]     
	
	u8:uint8[]   = [1,2,3]     
	u16:uint16[] = [1,2,3]     
	u32:uint32[] = [1,2,3]    
	u64:uint64[] = [1,2,3]    
	
	ri:real[] = [1,2,3]    
	r:real[] = [1.0,2.0,3.0]    
	t:text[] = ['a1','a2','a3']    
	b:bool[] = [true,true, false]	
|---------------------
| check i16:[1,2,3], i32:[1,2,3], i64:[1,2,3], u8:[1,2,3], u16:[1,2,3], u32:[1,2,3], u64:[1,2,3], ri:[1.0,2.0,3.0], r:[1.0,2.0,3.0], t:['a1','a2','a3'], b:[true,true,false]




|****************************************
| TEST apply int array step initialization
| TAGS apply array                         
|************************  
  a:int; b:int; c:int
  i16:int16[] = [a..b..c]     
  i32:int32[] = [a..b..c]     
  i64:int64[] = [a..b..c]     
  
  u8:uint8[]   = [a..b..c]     
  u16:uint16[] = [a..b..c]     
  u32:uint32[] = [a..b..c]    
  u64:uint64[] = [a..b..c]    
  
  r:real[] = [a..b..c] 
|---------------------
| set a:1, b:3, c:1
| check i16:[1,2,3], i32:[1,2,3], i64:[1,2,3], u8:[1,2,3], u16:[1,2,3], u32:[1,2,3], u64:[1,2,3], r:[1.0,2.0,3.0]
| set a:0, b:1, c:1
| check i16:[0,1], i32:[0,1], i64:[0,1], u8:[0,1], u16:[0,1], u32:[0,1], u64:[0,1], r:[0.0,1.0]
| set a:5, b:5, c:1
| check i16:[5], i32:[5], i64:[5], u8:[5], u16:[5], u32:[5], u64:[5], r:[5.0]
| set a:1, b:3, c:2
| check i16:[1,3], i32:[1,3], i64:[1,3], u8:[1,3], u16:[1,3], u32:[1,3], u64:[1,3], r:[1.0,3.0]
| set a:1, b:7, c:5
| check i16:[5], i32:[5], i64:[5], u8:[5], u16:[5], u32:[5], u64:[5], r:[5.0]



|****************************************
| TEST text constant  
| TAGS text constant apply                         
|************************  
  e1:text = ''
  e2:text = ""
  e3:char[] = ''
  e4:char[] = ""
  v1:text = 'vasa' 
  v2:text = "vasa" 
  v3:char[] = 'vasa' 
  v4:char[] = "vasa" 
|---------------------
| check e1: ''
| check e2: ''
| check e3: ''
| check e4: ''
| check v1: 'vasa'
| check v2: 'vasa'
| check v3: 'vasa'
| check v4: 'vasa'


|****************************************
| TEST apply int array initialization  
| TAGS apply array                         
|************************  
  i16:int16[] = [a..b]     
  i32:int32[] = [a..b]     
  i64:int64[] = [a..b]     
  
  u8:uint8[]   = [a..b]     
  u16:uint16[] = [a..b]     
  u32:uint32[] = [a..b]    
  u64:uint64[] = [a..b]    
  
  r:real[] = [a..b] 
|---------------------
| set a:1, b:3
| check i16:[1,2,3], i32:[1,2,3], i64:[1,2,3], u8:[1,2,3], u16:[1,2,3], u32:[1,2,3], u64:[1,2,3], r:[1.0,2.0,3.0]
| set a:0, b:1
| check i16:[0,1], i32:[0,1], i64:[0,1], u8:[0,1], u16:[0,1], u32:[0,1], u64:[0,1], r:[0.0,1.0]
| set a:5, b:5
| check i16:[5], i32:[5], i64:[5], u8:[5], u16:[5], u32:[5], u64:[5], r:[5.0]



|****************************************
| TEST req from a to b
| TAGS req user-function
|************************  
| in  a:int, b:int
| out  out:text 
|------------------------
  concat(a,b) = a.toText().concat(' ').concat(b)

  f(a,b) = 
          if(a>b)  concat(a, f(a-1,b))
          if(b>a)  concat(a, f(a+1,b)) 
          else a.toText()
              
  f(a,b)        
|---------------------
| set a:1, b:5
| check out: '1,2,3,4,5'
| set a :9, b:12
| check out: '9,10,11,12'
| set a:12, b:9
| check out: '12,11,10,9'





|****************************************
| TEST req array reverse 
| TAGS req user-function
|************************  
| in   t:text, i:int[]
| out  yt:text, yi:int[]
|------------------------
  reverse(t) =
        if(t.count()<2) t
        else t[1:].reverse().concat(t[0])
  
  t:text
  i:int[]

  yt = t.reverse()
  yi = i.reverse()          
        
|---------------------
| set i:[1,2,3,4,5,6,7,8,9],  t: "hello world"
| check yi:[9,8,7,6,5,4,3,2,1], t:"dlrow olleh"


|****************************************
| TEST req array sum 
| TAGS req user-function
|************************  
  mysum(arr, i) =
    if(i>=arr.count()) 0
    else arr[i] + mysum(arr, i+1)

  mysum(arr) = mysum(arr,0)  

  res = mysum(input) 
        
|---------------------
| set input:[1,2,3,4]
| check res:10
| set input:[1]
| check res:1
| set input:[1,-1]
| check res:0






|****************************************
| TEST toposort  
| TAGS user-function array reqursion lambda                         
|************************  

#Graph:
#    10--11-------12--------13 
#    /     \     /            \
#1--2--3---4---5---6---7---8---9      
#       \                       \
#        14--15-----------------16---17 

mutable a:int[]

#graph edges from-[to]
graph = [[1],[2],[3,10],[4,14],[5],[6,12],[7],[8],[9],[16],[11],[4,12],[13],[9],[15],[16],[17]]

#expected sort order
order = [1,2,3,10,11,4,5,6,7,8,12,13,9,14,15,16,17]

dfs(graph, , i) 
	=  



dfs(graph) = dfs(graph, graph.count().repeat(false),0) 


##foreach (it:10, cur: [1..10], i:i+1)  
##  -> if (it> cur) it else cur 
##
##foreach it,cur: [1..10] -> if (it> cur) it else cur 
##
##for it:10, cur: [1..10] -> if (it> cur) it else cur 
##for (it:10, cur: [1..10],  -> if (it> cur) it else cur 
##
##[1..10].fold:  
##       (cur,acc) -> if (cur>acc) cur else acc
##    
##[1..10].foreach from 10: 
##       (cur,acc) -> if (cur>acc) cur else acc
##
##
##[1..10].fold 
##    (cur,acc) -> if (cur>acc) cur else acc
##
##[1..10].map -> it*10
##
##[1..10].filter -> it.isGross() and it.age>15
##       .map    -> '{it.name}'s age is {it.age}'
##       .fold (acc, cur) = acc+cur
##[1..10].filter -> it>=2
         .map -> it*10
